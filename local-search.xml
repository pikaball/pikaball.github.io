<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[syzkaller源码阅读] 1. Loading of config and corpus</title>
    <link href="/2025/04/28/syzkaller%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1-Loading-of-config-and-corpus/"/>
    <url>/2025/04/28/syzkaller%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1-Loading-of-config-and-corpus/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在前一篇文章中，我们从文档了解了syzkaller的fuzz结构和使用方法。这一篇我们将正式开始源码阅读，从一切的入口开始。</p></blockquote><h2 id="Entry-Config"><a href="#Entry-Config" class="headerlink" title="Entry &amp; Config"></a>Entry &amp; Config</h2><p>程序的入口是在<code>syz-manager/manager.go</code>. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">if</span> !prog.GitRevisionKnown() &#123;<br>log.Fatalf(<span class="hljs-string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)<br>&#125;<br>log.EnableLogCaching(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>cfg, err := mgrconfig.LoadFile(*flagConfig)<br>    ...<br></code></pre></td></tr></table></figure><p>main函数解析参数，设置日志缓存长度，然后把配置文件解析到cfg变量。</p><p><code>flag.Parse()</code>会将命令行参数<code>-xxx</code>解析为<code>flagXxx</code>，这里的flagConfig就是在启动syz-manager时传入的配置文件路径。</p><p>我们直接跟进<code>pkg/mgrconfig/config.go</code> 看Config结构体定义，反引号包裹的结构体标签描述了此配置项在json格式配置文件中的key，注释中解释了每一个配置项的含义。</p><ul><li><code>workdir_template</code> : 指定一个目录，这个目录将在每一次创建虚拟机时被拷贝到供该虚拟机使用的临时目录中，这个临时目录的位置可以在qemu参数中使用<code>&#123;&#123;TEMPLATE&#125;&#125;</code> 指代，我们可以看到注释中给出了这样的示例：<code>&quot;qemu_args&quot;: &quot;-fda &#123;&#123;TEMPLATE&#125;&#125;/fd&quot;</code> ，即将模版中的fd挂载到软盘驱动器A</li><li><code>kernel_obj</code> : vmlinux所在目录，<strong>如果不是直接在源码树目录中执行的编译 ，还需要指定一下<code>kernel_src</code></strong> ，否则syzkaller会无法生成源码上的coverage报告</li></ul><p>其余部分不在这里详细列出<del>（懒得写）</del>，我们在后面的审计中碰到再进行描述。</p><p>我们接着看这一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br>    <span class="hljs-keyword">var</span> mode *Mode<br>    <span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> modes &#123;<br>        <span class="hljs-keyword">if</span> *flagMode == m.Name &#123;<br>            mode = m<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-literal">nil</span> &#123;<br>        flag.PrintDefaults()<br>        log.Fatalf(<span class="hljs-string">&quot;unknown mode: %v&quot;</span>, *flagMode)<br>    &#125;<br>    <span class="hljs-keyword">if</span> mode.CheckConfig != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err := mode.CheckConfig(cfg); err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatalf(<span class="hljs-string">&quot;%v mode: %v&quot;</span>, mode.Name, err)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> !mode.UseDashboard &#123;<br>        cfg.DashboardClient = <span class="hljs-string">&quot;&quot;</span><br>        cfg.HubClient = <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    ...<br></code></pre></td></tr></table></figure><p>其中，modes是一些预定义的Mode结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">modes = []*Mode&#123;<br>ModeFuzzing,<br>ModeSmokeTest,<br>ModeCorpusTriage,<br>ModeCorpusRun,<br>ModeRunTests,<br>ModeIfaceProbe,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在<code>syz-manager</code> 的帮助信息里看到对此的说明：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>-mode <span class="hljs-built_in">string</span><br>      mode <span class="hljs-keyword">of</span> operation, one <span class="hljs-keyword">of</span>:<br>       - fuzzing: <span class="hljs-keyword">the</span> default continuous fuzzing mode<br>       - smoke-test: <span class="hljs-built_in">run</span> smoke test <span class="hljs-keyword">for</span> syzkaller+kernel<br>              The test consists <span class="hljs-keyword">of</span> booting VMs <span class="hljs-keyword">and</span> <span class="hljs-built_in">running</span> <span class="hljs-keyword">some</span> simple test programs<br>              <span class="hljs-keyword">to</span> ensure <span class="hljs-keyword">that</span> fuzzing can proceed <span class="hljs-keyword">in</span> general. After completing <span class="hljs-keyword">the</span> test<br>              <span class="hljs-keyword">the</span> process exits <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">exit</span> status indicates success/failure.<br>              If <span class="hljs-keyword">the</span> kernel oopses during testing, <span class="hljs-keyword">the</span> report <span class="hljs-keyword">is</span> saved <span class="hljs-keyword">to</span> workdir/report.json.<br>       - corpus-triage: triage corpus <span class="hljs-keyword">and</span> <span class="hljs-keyword">exit</span><br>              This <span class="hljs-keyword">is</span> useful mostly <span class="hljs-keyword">for</span> benchmarking <span class="hljs-keyword">with</span> testbed.<br>       - corpus-<span class="hljs-built_in">run</span>: continuously <span class="hljs-built_in">run</span> <span class="hljs-keyword">the</span> corpus programs<br>       - <span class="hljs-built_in">run</span>-tests: <span class="hljs-built_in">run</span> unit tests<br>              Run sys/os/test/* tests <span class="hljs-keyword">in</span> various modes <span class="hljs-keyword">and</span> print results.<br>       - iface-probe: <span class="hljs-built_in">run</span> dynamic part <span class="hljs-keyword">of</span> kernel interface auto-extraction<br>              When <span class="hljs-keyword">the</span> probe <span class="hljs-keyword">is</span> finished, manager writes <span class="hljs-keyword">the</span> <span class="hljs-literal">result</span> <span class="hljs-keyword">to</span> workdir/interfaces.json <span class="hljs-built_in">file</span> <span class="hljs-keyword">and</span> exits.<br>       (default <span class="hljs-string">&quot;fuzzing&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>不指定mode就默认是fuzzing模式，也就是正常的模糊测试。</p><ul><li>smoke-test：执行一些简单样例检测syzkaller和内核配置是否正常</li><li>corpus-traige：语料库筛选</li><li>corpus-run：持续运行语料库中的程序</li><li>run-tests：运行 <code>sys/os/test/*</code> 目录下的测试</li><li>iface-probe：动态提取内核接口并写入 <code>workdir/interfaces.json</code></li></ul><p>寻找<code>CheckConfig</code> ，发现只有<code>ModeIfaceProbe</code> 实现了这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">CheckConfig: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg *mgrconfig.Config)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> cfg.Snapshot &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;snapshot mode is not supported&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Sandbox != <span class="hljs-string">&quot;none&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;sandbox \&quot;%v\&quot; is not supported (only \&quot;none\&quot;)&quot;</span>, cfg.Sandbox)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是这个模式的要求是config中不能指定Snapshot为True（snapshot选项允许vm从上一次运行的快照中热启动），且sandbox需要为none。</p><p>检查完config和mode之后，进入<code>RunManager(mode, cfg)</code> ，这个函数用来初始化Manager并进入fuzz循环，它主要做了这么一些事情：</p><ul><li>根据config传入的vm类型创建vm池</li><li>创建一个Reporter，这个东西的主要组件是一系列正则表达式，用于从vm输出中提取各种信息</li><li>从workdir中加载语料库（如果有的话）</li><li>启动一个HTTP Server，用于运行dashboard</li><li>启动RPC Server，用于和vm中的executor交互</li><li>进入Fuzz主循环</li></ul><h2 id="vm池"><a href="#vm池" class="headerlink" title="vm池"></a>vm池</h2><p>在RunManager的开头，创建了虚拟机池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RunManager</span><span class="hljs-params">(mode *Mode, cfg *mgrconfig.Config)</span></span> &#123;<br><span class="hljs-keyword">var</span> vmPool *vm.Pool<br><span class="hljs-keyword">if</span> !cfg.VMLess &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>vmPool, err = vm.Create(cfg, *flagDebug)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> vmPool.Close()<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>跟进<code>vm.Create</code>, flagDebug是从命令行参数<code>-debug</code> 解析而来，表示调试模式，在这个模式下只有vm池中将只有一个vm，且vm中同一时刻将只有一个进程在执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(cfg *mgrconfig.Config, debug <span class="hljs-type">bool</span>)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>typ, ok := vmimpl.Types[vmType(cfg.Type)]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)<br>&#125;<br>env := &amp;vmimpl.Env&#123;<br>Name:      cfg.Name,<br>OS:        cfg.TargetOS,<br>Arch:      cfg.TargetVMArch,<br>Workdir:   cfg.Workdir,<br>Image:     cfg.Image,<br>SSHKey:    cfg.SSHKey,<br>SSHUser:   cfg.SSHUser,<br>Timeouts:  cfg.Timeouts,<br>Snapshot:  cfg.Snapshot,<br>Debug:     debug,<br>Config:    cfg.VM,<br>KernelSrc: cfg.KernelSrc,<br>&#125;<br>impl, err := typ.Ctor(env)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>count := impl.Count()<br><span class="hljs-keyword">if</span> debug &amp;&amp; count &gt; <span class="hljs-number">1</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;limiting number of VMs from %v to 1 in debug mode&quot;</span>, count)<br>count = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;Pool&#123;<br>impl:       impl,<br>typ:        typ,<br>workdir:    env.Workdir,<br>template:   cfg.WorkdirTemplate,<br>timeouts:   cfg.Timeouts,<br>count:      count,<br>snapshot:   cfg.Snapshot,<br>hostFuzzer: cfg.SysTarget.HostFuzzer,<br>statOutputReceived: stat.New(<span class="hljs-string">&quot;vm output&quot;</span>, <span class="hljs-string">&quot;Bytes of VM console output received&quot;</span>,<br>stat.Graph(<span class="hljs-string">&quot;traffic&quot;</span>), stat.Rate&#123;&#125;, stat.FormatMB),<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>vmimpl.Types</code> 预置了一些Type，这些预置值在vm包下的其他文件中注册，例如<code>vm/qemu/qemu.go</code> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> _ vmimpl.Infoer = (*instance)(<span class="hljs-literal">nil</span>)<br>vmimpl.Register(<span class="hljs-string">&quot;qemu&quot;</span>, vmimpl.Type&#123;<br>Ctor:       ctor,<br>Overcommit: <span class="hljs-literal">true</span>,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Ctor</code>是Constructor，Type结构体包含了Ctor和两个布尔值，显然Ctor就是vm pool创建的核心逻辑，我们就只看qemu，别的vm不管了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>archConfig := archConfigs[env.OS+<span class="hljs-string">&quot;/&quot;</span>+env.Arch]<br>cfg := &amp;Config&#123;<br>Count:       <span class="hljs-number">1</span>,<br>CPU:         <span class="hljs-number">1</span>,<br>Mem:         <span class="hljs-number">1024</span>,<br>ImageDevice: <span class="hljs-string">&quot;hda&quot;</span>,<br>Qemu:        archConfig.Qemu,<br>QemuArgs:    archConfig.QemuArgs,<br>NetDev:      archConfig.NetDev,<br>Snapshot:    <span class="hljs-literal">true</span>,<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>看一下<code>archConfigs[&quot;linux/amd64&quot;]</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;linux/amd64&quot;</span>: &#123;<br>Qemu:     <span class="hljs-string">&quot;qemu-system-x86_64&quot;</span>,<br>QemuArgs: <span class="hljs-string">&quot;-enable-kvm -cpu host,migratable=off&quot;</span>,<br><span class="hljs-comment">// e1000e fails on recent Debian distros with:</span><br><span class="hljs-comment">// Initialization of device e1000e failed: failed to find romfile &quot;efi-e1000e.rom</span><br><span class="hljs-comment">// But other arches don&#x27;t use e1000e, e.g. arm64 uses virtio by default.</span><br>NetDev: <span class="hljs-string">&quot;e1000&quot;</span>,<br>RngDev: <span class="hljs-string">&quot;virtio-rng-pci&quot;</span>,<br>CmdLine: []<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;root=/dev/sda&quot;</span>,<br><span class="hljs-string">&quot;console=ttyS0&quot;</span>,<br>&#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>这些都是用于创建qemu虚拟机的命令行参数，archConfigs用于构建默认Config，这里的Config是qemu包的Config，区别于manager使用的Config。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">if</span> err := config.LoadData(env.Config, cfg); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to parse qemu vm config: %w&quot;</span>, err)<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>这里的env.Config的值从cfg.VM继承而来，这个字段是一个裸json :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">VM json.RawMessage <span class="hljs-string">`json:&quot;vm&quot;`</span><br></code></pre></td></tr></table></figure><p>读到这里我们也能知道syzkaller config中的<code>vm</code>字段定义是依赖于vm类型（即config中的<code>type</code>字段）的。</p><p>再往后是一些基本的参数检查，检查结束后创建一个<code>vmimpl.Pool</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>...<br>pool := &amp;Pool&#123;<br>env:        env,<br>cfg:        cfg,<br>version:    version,<br>target:     targets.Get(env.OS, env.Arch),<br>archConfig: archConfig,<br>&#125;<br><span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>返回到<code>vm.Create</code>函数，这里的返回值赋给<code>impl</code> ，再套进<code>vm.Pool</code>结构体中，至此vm池创建结束。</p><h2 id="Corpus-Preload"><a href="#Corpus-Preload" class="headerlink" title="Corpus Preload"></a>Corpus Preload</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RunManager</span><span class="hljs-params">(mode *Mode, cfg *mgrconfig.Config)</span></span> &#123;<br>...<br>mgr.initStats() <span class="hljs-comment">// 初始化各种统计指标</span><br><span class="hljs-keyword">if</span> mgr.mode.LoadCorpus &#123;<br><span class="hljs-keyword">go</span> mgr.preloadCorpus()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(mgr.corpusPreload)<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里进行了语料库的载入，条件是<code>mgr.mode.LoadCorpus</code> 为true，只有<code>ModeFuzzing</code> ，<code>ModeCorpusTriage</code> ，<code>ModeCorpusRun</code> 三种模式满足。</p><p>跟进<code>preloadCorpus</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> preloadCorpus() &#123;<br>info, err := manager.LoadSeeds(mgr.cfg, <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to load corpus: %v&quot;</span>, err)<br>&#125;<br>mgr.fresh = info.Fresh<br>mgr.corpusDB = info.CorpusDB<br>mgr.corpusPreload &lt;- info.Candidates<br>&#125;<br></code></pre></td></tr></table></figure><p>LoadSeeds:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadSeeds</span><span class="hljs-params">(cfg *mgrconfig.Config, immutable <span class="hljs-type">bool</span>)</span></span> (Seeds, <span class="hljs-type">error</span>) &#123;<br>...<br>info.CorpusDB, err = db.Open(filepath.Join(cfg.Workdir, <span class="hljs-string">&quot;corpus.db&quot;</span>), !immutable)<br>...<br></code></pre></td></tr></table></figure><p>注意到immutable这个参数，其字面意思是不可变。</p><p>全局搜索LoadSeeds的引用就能发现只有两处进行了调用，一次是这里，进入fuzz loop前，传入false；另一处在<code>pkg/manager/diff.go#RunDiffFuzzer</code>，传入的是true，向上追踪，只有两处调用了这个方法，分别是<code>tools/syz-diff/diff.go#main</code>,<code>syz-cluster/workflow/fuzz-step/main.go#run</code>。都不是syz-manager会经过的路径，我们暂且不看。</p><p>接着看db.Open，syzkaller的db是一个自己实现的键值对数据库，这个函数负责将workdir中的corpus.db文件加载到<code>db.DB</code>结构体中，repair&#x3D;true</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Open opens the specified database file.</span><br><span class="hljs-comment">// If the database is corrupted and reading failed, then it returns an non-nil db</span><br><span class="hljs-comment">// with whatever records were recovered and a non-nil error at the same time.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(filename <span class="hljs-type">string</span>, repair <span class="hljs-type">bool</span>)</span></span> (*DB, <span class="hljs-type">error</span>) &#123;<br>db := &amp;DB&#123;<br>filename: filename,<br>&#125;<br><span class="hljs-keyword">var</span> deserializeErr <span class="hljs-type">error</span><br>db.Version, db.Records, db.uncompacted, deserializeErr = deserializeFile(db.filename)<br><span class="hljs-comment">// Deserialization error is considered a &quot;soft&quot; error if repair == true,</span><br><span class="hljs-comment">// but compact below ensures that the file is at least writable.</span><br><span class="hljs-keyword">if</span> deserializeErr != <span class="hljs-literal">nil</span> &amp;&amp; !repair &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, deserializeErr<br>&#125;<br><span class="hljs-keyword">if</span> err := db.compact(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> db, deserializeErr<br>&#125;<br></code></pre></td></tr></table></figure><p>desrialize的具体细节不重要，注意到这里对反序列化错误的处理：当读取失败且repair为true时，基于已经读取到的键值对进行文件格式恢复，即重新序列化，这样就可以应对语料库文件尾破损的情况。</p><p>回到<code>LoadSeeds</code> 里，返回值保存到<code>info.corpusDB</code> ，这里面的键值对(Record)是byte[]形式，还需要将字节流还原为种子(Seed)，我们已经解释过，种子实质是fuzz过程中产生的有价值的输入程序（syscall序列），在syzkaller的源码中对应结构体<code>prog.Prog</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadSeeds</span><span class="hljs-params">(cfg *mgrconfig.Config, immutable <span class="hljs-type">bool</span>)</span></span> (Seeds, <span class="hljs-type">error</span>) &#123;<br>...<br>outputs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *input, <span class="hljs-number">32</span>)<br> chErr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>chErr &lt;- readInputs(cfg, info.CorpusDB, outputs)<br><span class="hljs-built_in">close</span>(outputs)<br>&#125;()<br>...<br></code></pre></td></tr></table></figure><p>看一眼<code>readInputs</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readInputs</span><span class="hljs-params">(cfg *mgrconfig.Config, db *db.DB, output <span class="hljs-keyword">chan</span> *input)</span></span> <span class="hljs-type">error</span> &#123;<br>procs := runtime.GOMAXPROCS(<span class="hljs-number">0</span>)<br>inputs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *input, procs)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(procs)<br><br><span class="hljs-keyword">defer</span> wg.Wait()<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(inputs)<br><span class="hljs-keyword">for</span> p := <span class="hljs-number">0</span>; p &lt; procs; p++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> inp := <span class="hljs-keyword">range</span> inputs &#123;<br>inp.Prog, inp.Err = ParseSeed(cfg.Target, inp.Data)<br>output &lt;- inp<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-keyword">for</span> key, rec := <span class="hljs-keyword">range</span> db.Records &#123;<br>inputs &lt;- &amp;input&#123;<br>Key:  key,<br>Data: rec.Val,<br>&#125;<br>&#125;<br>seedPath := filepath.Join(<span class="hljs-string">&quot;sys&quot;</span>, cfg.TargetOS, <span class="hljs-string">&quot;test&quot;</span>)<br>seedDir := filepath.Join(cfg.Syzkaller, seedPath)<br><span class="hljs-keyword">if</span> osutil.IsExist(seedDir) &#123;<br>seeds, err := os.ReadDir(seedDir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to read seeds dir: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">for</span> _, seed := <span class="hljs-keyword">range</span> seeds &#123;<br>data, err := os.ReadFile(filepath.Join(seedDir, seed.Name()))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to read seed %v: %w&quot;</span>, seed.Name(), err)<br>&#125;<br>inputs &lt;- &amp;input&#123;<br>IsSeed: <span class="hljs-literal">true</span>,<br>Path:   filepath.Join(seedPath, seed.Name()),<br>Data:   data,<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>syzkaller会从两个地方加载种子，一个是workdir下的corpus.db，一个是syzkaller源码目录下的<code>sys/&#123;os&#125;/test</code> ，如果后者加载失败，那么LoadSeeds将直接返回一个空集合。这里种子的加载是一个生产-消费模式的写法，procs是可用处理器数量，inputs是缓冲长度为procs的输入通道，同时procs个goroutine负责从inputs中读取和解析数据，解析结果输入到output这个channel中。</p><p>再回到LoadSeeds中，我们会发现对outputs的处理也是一个异步结构，readInputs是用goroutine启动的，下面的for循环等待从outputs中接收数据，将有效种子加入candidates，candidates是fuzz的初始输入，在执行这些初始输入的基础上去做变异等一系列后续操作。</p><p>这里对“有效”的定义是<code>inp.Prog</code> 是否为nil，即<strong>如果从原始数据中还原出了一个当前fuzz目标可执行的syscall序列，那么就认为种子有效。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadSeeds</span><span class="hljs-params">(cfg *mgrconfig.Config, immutable <span class="hljs-type">bool</span>)</span></span> (Seeds, <span class="hljs-type">error</span>) &#123;<br>...<br> <span class="hljs-keyword">for</span> inp := <span class="hljs-keyword">range</span> outputs &#123;<br><span class="hljs-keyword">if</span> inp.Prog == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> inp.IsSeed &#123;<br><span class="hljs-keyword">if</span> errors.Is(inp.Err, ErrSkippedTest) &#123;<br>skippedSeeds++<br>log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;seed %s is skipped: %s&quot;</span>, inp.Path, inp.Err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>brokenSeeds++<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;seed %s is broken: %s&quot;</span>, inp.Path, inp.Err)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>brokenCorpus = <span class="hljs-built_in">append</span>(brokenCorpus, inp.Key)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>flags := corpusFlags<br><span class="hljs-keyword">if</span> inp.IsSeed &#123;<br><span class="hljs-keyword">if</span> _, ok := info.CorpusDB.Records[hash.String(inp.Prog.Serialize())]; ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Seeds are not considered &quot;from corpus&quot; (won&#x27;t be rerun multiple times)</span><br><span class="hljs-comment">// b/c they are tried on every start anyway.</span><br>flags = fuzzer.ProgMinimized<br>&#125;<br>candidates = <span class="hljs-built_in">append</span>(candidates, fuzzer.Candidate&#123;<br>Prog:  inp.Prog,<br>Flags: flags,<br>&#125;)<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>观察到candidates保存了Prog和Flags两个变量，后者用于标识此程序的类型，其默认来源于<code>corpusFlags := versionToFlags(info.CorpusDB.Version)</code> ，整个语料库的统一标识；当一个有效种子不在<code>info.CorpusDB.Records</code> 中，即由<code>sys/&#123;os&#125;/test</code> 目录加载而来时，设置标志为<code>ProgMinimized</code> ，字面上就是“已经最小化的”，关于最小化这个事情我们放到后面再解释。</p><p>总之，被预加载的语料最终在<code>preloadCorpus</code>的结尾会被输送到<code>mgr</code>，我们注意到这是贯穿fuzz始终的最高层全局变量。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本文从 syz-manager 的入口函数出发，详细梳理了 syzkaller 在启动阶段的若干关键步骤：加载配置文件、创建虚拟机池，并开始载入已有的语料库（corpus）。<br>下一篇文章，我们将接着审计RunManager函数，深入RPC Server的构建和启动细节。</p>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>code review</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[syzkaller源码阅读] 0. Run &amp; Read doc</title>
    <link href="/2025/04/04/syzkaller%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-0-Run-Read-doc/"/>
    <url>/2025/04/04/syzkaller%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-0-Run-Read-doc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>出于毕设和研究生阶段的工作需要，我不得不尽早做完syzkaller的审计工作。为了方便复盘和分享，干脆边审边写blog了，挖个大坑。</p></blockquote><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p><a href="https://github.com/google/syzkaller">syzkaller</a>是目前最流行的内核模糊测试框架，要fuzz内核的话基本上没有别的更好的选择。</p><blockquote><p>注：整个审计工作将保持在这个commit上进行：<code>c799dfdd5648677612604d10e2c13075eda21582</code> </p></blockquote><p>如果你此前没有审计过go项目，也不是很懂fuzz，那么应该先对着readme给项目跑起来，再去读一遍文档，理解开发者的设计意图，做完了这些事情，才可以有底气去开始我们的审计。</p><p>运行第一个kernel fuzz实例并不困难，照着readme一步一步来就好了，大概的步骤是编译syzkaller -&gt; 编译内核 -&gt; 创建用户空间镜像 -&gt; syzkaller config -&gt; Run syz-manager, 主要参阅<code>docs/setup.md</code>, <code>docs/usage.md</code></p><p>你可以从syzkaller的在线实例上获取现成的kernel config: <a href="https://syzkaller.appspot.com/upstream">syzbot</a></p><p>这是一个syzkaller config示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux/amd64&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;http&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.0.0.0:56741&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;workdir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/v6.11&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;kernel_obj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/linux&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/v6.11/bullseye.img&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;syzkaller&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/syzkaller&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sshkey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/v6.11/bullseye.id_rsa&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;procs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">12</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qemu&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;vm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;cpu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;mem&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8192</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;kernel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/linux/arch/x86/boot/bzImage&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>syz-manager</code>跑起来之后，访问你在配置文件中指定的webui地址，应该可以看到如下仪表盘：</p><p><img src="/../img/syzkaller/0/dashboard.png" alt="syz-manager dashboard"></p><p>多运行一段时间，确认vm没有爆出一些一看就不对的错误。</p><ul><li><strong>lost connection</strong>: ssh 出问题了，建议在syzkaller启动前用你获得的内核镜像和用户空间镜像手动起一个qemu，看看能不能走ssh连进去</li><li><strong>no output from test machine</strong>: 多半是内核编译得不对，请确保采用了版本完全匹配的<code>.config</code></li></ul><p>总之，fuzz顺利启动了，接下来我们去从头到尾看一遍文档。</p><h1 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h1><p>syzkaller根目录的readme给了一些指引：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [<span class="hljs-string">How to install syzkaller</span>](<span class="hljs-link">docs/setup.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to use syzkaller</span>](<span class="hljs-link">docs/usage.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How syzkaller works</span>](<span class="hljs-link">docs/internals.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to install syzbot</span>](<span class="hljs-link">docs/setup_syzbot.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to contribute to syzkaller</span>](<span class="hljs-link">docs/contributing.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to report Linux kernel bugs</span>](<span class="hljs-link">docs/linux/reporting_kernel_bugs.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Tech talks and articles</span>](<span class="hljs-link">docs/talks.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Research work based on syzkaller</span>](<span class="hljs-link">docs/research.md</span>)<br></code></pre></td></tr></table></figure><p>另外，docs目录下有一些子目录，对应不同os，看<code>linux</code>目录下的文件即可。</p><p>我们暂时只关心“Linux的fuzz工作是如何运作的”，别的都可以先不看。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><code>docs/internals.md</code>介绍了syzkaller的运行结构.</p><p><code>docs/linux/internals.md</code> -&gt; [<code>docs/linux/external_fuzzing_network.md</code> , <code>docs/linux/external_fuzzing_usb.md</code>] 介绍了linux下的特殊工作结构，即关于如何fuzz network模块和USB模块，这部分将在后文提及，暂时跳过。</p><p>syzkaller的结构如下图所示。</p><p><img src="/../img/syzkaller/0/process_structure.png" alt="syzkaller process structure"></p><p>syzkaller的主要组件是<code>syz-manager</code>和<code>syz-executor</code>, 前者在host上运行，控制整个fuzz工作，后者在vm上运行，负责在vm中执行程序并向manager发送反馈信息（报错，覆盖率等）。</p><p>在启动一个vm时，<code>syz-manager</code>通过ssh发送静态编译的executor并运行，之后，manager和executor将通过rpc协议进行通信。</p><p>syzkaller对vm的每一个输入都是由一串系统调用构成的程序，即syscall序列。</p><p>为什么是syscall序列？我们fuzz的对象是内核，目标是由用户态输入引发内核异常，而用户态和内核态的主要交互方式就是系统调用，至于其他交互方式，比如硬件上的插拔，这也可以使用自定义的syscall模拟，我们将在network和usb的部分看到这样的伪syscall。</p><p>syz-manager运行时会维护workdir，workdir中包含崩溃用例（crashes）和语料库（corpus），可以做这样一个简单描述：如果一个fuzz输入（syscall序列）运行时产生了任何告警或错误，那么就将其算作crash；如果一个fuzz输入产生了新的覆盖，那么就将其加入语料库。语料库的作用就是提供fuzz变异的种子，即在一个“有趣的用例”的基础上进一步测试。</p><h2 id="syzlang"><a href="#syzlang" class="headerlink" title="syzlang"></a>syzlang</h2><p>我们已经知道syzkaller在做的事是不断生成syscall序列发到虚拟机里执行，那么这些序列是如何被构造的呢？</p><p>syzkaller使用syscall description language(简称syzlang) 来描述系统调用的参数约束，以下是文档中给出的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd<br>read(fd fd, buf buffer[out], count len[buf])<br>close(fd fd)<br>open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>这个示例本身是过于简单的，可以在<code>sys/$os</code>下看到syzkaller预置的syzlang，比如在<code>sys/linux/dev_fb.txt</code>中，可以看到这样的规约：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">openat<span class="hljs-variable">$fb0</span>(fd const<span class="hljs-selector-attr">[AT_FDCWD]</span>, file ptr<span class="hljs-selector-attr">[in, string[<span class="hljs-string">&quot;/dev/fb0&quot;</span>]</span>], flags flags<span class="hljs-selector-attr">[open_flags]</span>, mode const<span class="hljs-selector-attr">[0]</span>) fd_fb<br>openat<span class="hljs-variable">$fb1</span>(fd const<span class="hljs-selector-attr">[AT_FDCWD]</span>, file ptr<span class="hljs-selector-attr">[in, string[<span class="hljs-string">&quot;/dev/fb1&quot;</span>]</span>], flags flags<span class="hljs-selector-attr">[open_flags]</span>, mode const<span class="hljs-selector-attr">[0]</span>) fd_fb<br><br>write<span class="hljs-variable">$fb</span>(fd fd_fb, data ptr<span class="hljs-selector-attr">[in, array[int8]</span>], len bytesize<span class="hljs-selector-attr">[data]</span>)<br>read<span class="hljs-variable">$fb</span>(fd fd_fb, data ptr<span class="hljs-selector-attr">[out, array[int8]</span>], len bytesize<span class="hljs-selector-attr">[data]</span>)<br>mmap<span class="hljs-variable">$fb</span>(addr vma, len len<span class="hljs-selector-attr">[addr]</span>, prot flags<span class="hljs-selector-attr">[mmap_prot]</span>, flags flags<span class="hljs-selector-attr">[mmap_flags]</span>, fd fd_fb, off intptr<span class="hljs-selector-attr">[0:0x100000, 0x1000]</span>)<br></code></pre></td></tr></table></figure><p>注意到系统调用名后有<code>$</code>符号，这是表示使用不同参数约束的syscall，例如上面的两个openat。（syzlang的详细语法描述可以参见<code>docs/syscall_descriptions_syntax.md</code>）</p><p>这样做的好处显而易见，因为有些syscall的处理逻辑非常多，在不同功能&#x2F;模块下需要不同的参数约束，典型的例子是ioctl，其行为完全取决于传入的cmd参数以及绑定的设备文件，我们在kernel中可以看到ioctl的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(ioctl, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg)<br>&#123;<br>CLASS(fd, f)(fd);<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (fd_empty(f))<br><span class="hljs-keyword">return</span> -EBADF;<br><br>error = security_file_ioctl(fd_file(f), cmd, arg);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br>error = do_vfs_ioctl(fd_file(f), fd, cmd, arg);<br><span class="hljs-keyword">if</span> (error == -ENOIOCTLCMD)<br>error = vfs_ioctl(fd_file(f), cmd, arg);<br><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们按照这个定义在syslang中直接这样写而不添加其变种：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ioctl(fd <span class="hljs-built_in">int32</span>, cmd <span class="hljs-built_in">int32</span>, arg <span class="hljs-built_in">int64</span>)<br></code></pre></td></tr></table></figure><p>……那就完蛋了，fuzz跑到猴年马月都出不了成果。举个例子，usb bus上的控制消息传递，需要一个指向usb设备的fd，特定的cmd值，并且把arg构造成指向一个urb的指针才可以进到相关逻辑。</p><p>而在syzlang中把这样的syscall拆分成带有更具体语义的变种，fuzz时就可以产生更多有效的输入和变异，提高fuzz效率。</p><p>syzkaller中内置的规约基本是完善的，虽然针对大量协议可以进一步做细化，但这个话题不在本系列文章的讨论范围，我们直接拿着用就好了。</p><h2 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a>coverage</h2><p>在fuzz linux内核时，syzkaller依靠KCOV机制来完成覆盖率信息收集，覆盖率信息将会在更新语料库时起到参考作用。</p><p>启用选项<code>CONFIG_KCOV=y</code>，内核编译时会进行基本块插桩，当代码运行到这些位置就会进行kcov相关调用，返回程序运行时命中的地址，进而实现覆盖率记录。</p><p>在得到kcov信息后，syzkaller使用binutils将地址转换为源代码位置，<code>docs/linux/coverage.md</code>解释了这一步具体的操作流，此处略过。</p><p>在web dashboard上可以直观地查看kernel每一个源码文件的coverage(<code>/cover</code>)。</p><p><img src="/../img/syzkaller/0/coverage.png" alt="coverage"></p><h2 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h2><p>所有fuzz工具的目标都是产生crash，至于如何从crash到exploit，这不在fuzz的讨论范围内。</p><p>引用一下<a href="https://www.ruanx.net/afl-source-1/">机器猫先生的博客</a>：</p><blockquote><p>归根结底，一个漏洞到底有没有价值，需要很多外部知识——例如，假如某个输入能让程序额外运行一秒钟，这对于 nginx 来说是巨大问题；但对于 checkpng 之类的小程序，便是无关紧要的。一个缓冲区 over-read 漏洞，对于 openssl 是致命的，但对于 gimp 这类程序而言，只是多了个让程序崩溃的 bug，大家并不特别关心其安全方面的危险。由于一个漏洞的价值难以衡量，笔者决定不钻研这个问题，仍以 crash 数量为衡量 fuzzer 好坏的第一标准。</p></blockquote><h3 id="report"><a href="#report" class="headerlink" title="report"></a>report</h3><p>syzkaller在发现crash后将其保存至workdir。</p><p><img src="/../img/syzkaller/0/crash-log.png" alt="crash info"></p><p>其中，<code>description</code>作为crash的名称，<code>logN</code>是syzkaller执行该用例时的日志以及vm中的输出信息，<code>machineInfoN</code>是执行该用例的vm配置信息，<code>reportN</code>则是在前两者基础上经过处理的crash报告。</p><h3 id="reproduce"><a href="#reproduce" class="headerlink" title="reproduce"></a>reproduce</h3><p>fuzz过程中会分出一部分虚拟机用于crash的复现（reproduce）。复现的意义在于，将原始触发crash的syscall序列尽可能简化，并验证该crash是否稳定可重复。</p><p>syzkaller提供了两个复现器，<code>C reproducer</code>和<code>Syz reproducer</code>，优先使用后者。</p><p>fuzz运行一段时间后，dashboard上就可以看到crash的信息了：</p><p><img src="/../img/syzkaller/0/crash.png" alt="crash"></p><p><code>has repro</code>表示使用<code>Syz reproducer</code>复现成功，提供一个syscall序列：</p><p><img src="/../img/syzkaller/0/syz-repro.png" alt="Syz repro"></p><p><code>has C repro</code>则对应<code>C reproducer</code>，提供一个C编写的程序。</p><p><img src="/../img/syzkaller/0/c-repro.png" alt="C repro"></p><p>此外，还可以使用syzkaller提供的工具进行手动reproduce并执行复现程序，参考<code>docs/reproducing_crashes.md</code></p><h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><p>syzkaller提供了很多实用小工具，都在<code>tools</code>目录下。</p><p><code>syz-cover</code>可以使用kcov信息（从web dashboard的<code>/rawcover</code>获取）生成可视化的coverage报告，<code>syz-benchcmp</code>可以接收两个覆盖率记录生成对比图，<code>syz-db</code>可以添加&#x2F;移除corpus.db中的语料，其他的在这里就不一一列举了，可以自行探索。</p><h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><p>本文梳理了syzkaller的启动流程和文档信息，大致描述了syzkaller的运行结构，从文档初窥syzkaller的系统性设计思路。下一篇将正式开始源码审计，分析syzkaller的架构逻辑和策略实现。</p>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>code review</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php容器远程调试指北</title>
    <link href="/2024/08/07/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/"/>
    <url>/2024/08/07/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h1><p>本机windows，服务器Ubuntu，服务器上跑一个php docker容器，本机使用IDE PhpStorm，需要服务器可以通过ip访问到本机。</p><p>本文以一个thinkphp应用为例，本机和服务器上各有一份代码。</p><p>容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 8000:8000 -p 9003:9003 -v .:/think php:8 /bin/bash<br></code></pre></td></tr></table></figure><p>8000是web端口，9003是调试端口</p><h1 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h1><h2 id="容器内安装Xdebug"><a href="#容器内安装Xdebug" class="headerlink" title="容器内安装Xdebug"></a>容器内安装Xdebug</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pecl install xdebug<br>docker-php-ext-enable xdebug<br></code></pre></td></tr></table></figure><p>xdebug安装成功时会回显xdebug.so的路径，待会要写到配置文件里。</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/xdebug-install.png"></p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install -y vim<br>vim /usr/local/etc/php/conf.d/xdebug.ini<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">zend_extension</span>=/usr/local/lib/php/extensions/<span class="hljs-literal">no</span>-debug-non-zts-<span class="hljs-number">20230831</span>/xdebug.so<br><span class="hljs-attr">xdebug.idekey</span>=PHPSTORM<br><span class="hljs-comment">; 进行调试所需要携带的IDEKEY</span><br><span class="hljs-attr">xdebug.discover_client_host</span> = <span class="hljs-literal">Off</span><br><span class="hljs-attr">xdebug.client_host</span>=<span class="hljs-string">&quot;x.x.x.x&quot;</span><br><span class="hljs-comment">; 这里是物理机，即IDE所在机器的ip</span><br><span class="hljs-attr">xdebug.mode</span>=profile,trace,debug<br><span class="hljs-attr">xdebug.start_with_request</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">xdebug.client_port</span> = <span class="hljs-number">9003</span><br><span class="hljs-attr">xdebug.remote_handler</span> = dbgp<br><span class="hljs-attr">xdebug.log</span> = /tmp/xdebug.log<br><span class="hljs-attr">xdebug.remote_enable</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">xdebug.remote_port</span> = <span class="hljs-number">9003</span><br></code></pre></td></tr></table></figure><h2 id="IDE配置"><a href="#IDE配置" class="headerlink" title="IDE配置"></a>IDE配置</h2><p><code>Settings -&gt; PHP</code>，首先为你的IDE添加一个可用的php解释器，我这里直接用了服务器上的，版本没有严格要求，差不太多就行</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/interpreter.png"></p><p>然后添加一个服务器，端口是web的端口，添加文件路径映射</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/serverconfi.png"></p><p><code>PHP -&gt; 调试</code>，确认一下调试端口是否正确</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/port.png"></p><p><code>PHP -&gt; 调试 -&gt; DBGp代理</code>，填一下IDEKEY和服务器的ip-port，与调试端口一致</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/DBGp_proxy.png"></p><p>最后添加一个PHP远程调试配置，服务器选择之前在设置里添加过的，然后填写IDEKEY</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/debug_config.png"></p><h1 id="开始debug"><a href="#开始debug" class="headerlink" title="开始debug"></a>开始debug</h1><p>IDE里下个断点，用刚才的配置开始调试</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/breakpoint.png"></p><p>到web根目录把服务跑起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">php think run<br></code></pre></td></tr></table></figure><p>浏览器发一个能使代码运行到断点处的请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/Lilac/de?data=aaaa<br></code></pre></td></tr></table></figure><p>就能看到断下来了：<br><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/debug.png"></p><h1 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h1><p>遇到过一些很抽象的问题……总之如果断不下来，可以尝试如下思路：</p><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p>IDE重新开启调试，以及重启web服务，两边都试试，并且可能受到重启的次序的影响</p><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>请求里加个get参数：<code>XDEBUG_SESSION_START=PHPSTORM</code></p><p>P.S. 搜索到的文章都写到了这一点，但事实上似乎没加也能断。</p><p>如果确定是这个问题，那么你可以安装一个叫Xdebug Helper的浏览器插件，它可以帮你自动化完成这个操作，不需要每次手动加。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hensel&#39;s Lifting Method</title>
    <link href="/2024/03/22/Hensel-s-Lifting-Method/"/>
    <url>/2024/03/22/Hensel-s-Lifting-Method/</url>
    
    <content type="html"><![CDATA[<p>近日尝试用sagemath自带的roots()求解$f(x) \equiv 0 \pmod{p^a}$，发现速度极慢。了解到Hensel’s Lemma可以解决这个问题，但我在sagemath的申必文档中并未搜索到该方法的直接实现。故自己写了一个。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><a href="https://en.wikipedia.org/wiki/Hensel's_lemma">Hensel’s lemma</a></p><p>Hensel’s Lemma 用于将 $f(x) \equiv 0 \pmod {p}$ 的解提升至$Zmod(p^a)$. (p为素数)</p><br><p>下面的算法称之为 <strong>Hensel’s lifting method</strong> :</p><p>首先，已知$x \equiv r_{k-1}$ 为 $f(x) \equiv 0 \pmod {p^{k-1}}$ 的解。</p><p>接下来将数域由$GF(p^{k-1})$提升至$GF(p^k)$，记 $r_k$ 为 $f(x) \equiv 0 \pmod {p^{k}}$ 的解</p><ul><li>若 $f’(r_{k-1}) \not\equiv 0$, 则有唯一的$t$使得 $f(r_{k-1} + tp^{k-1}) \equiv 0 \pmod{p^k}$ 成立，此时$r_k &#x3D; r_{k-1} - \displaystyle\frac{f(r_{k-1})}{f’(r_{k-1})}$</li><li>若 $f’(r_{k-1}) \equiv 0$, 且 $f(r_{k-1}) \equiv 0$，则t为任意整数，$r_k &#x3D; r_{k-1}$</li><li>若 $f’(r_{k-1}) \equiv 0$, 且 $f(r_{k-1}) \not\equiv 0$，则没有满足条件的整数t，无法利用$r_{k-1}$求解</li></ul><p>以上步骤循环，可以将$f(x) \equiv 0$ 在 $GF(p^a)$上的求解规约到 $GF(p)$</p><br><p>注意到$\displaystyle\frac{f(r_{k-1})}{f’(r_{k-1})}$未必能直接产生整数，将计算放到p-adic ring上更方便。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hensel_solve</span>(<span class="hljs-params">f, p, r</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Solves polynomial roots in the ring Zmod(p**r) using Hensel&#x27;s lifting method.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Parameters:</span><br><span class="hljs-string">    f (polynomial): The polynomial equation.</span><br><span class="hljs-string">    p (int): A prime number.</span><br><span class="hljs-string">    r (int): The exponent.</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Raises:</span><br><span class="hljs-string">    ValueError: If p is not a prime number or if f has no roots.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_prime(p):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;p must be a prime&quot;</span>)<br>    f = f.change_ring(Zp(p))<br>    F = f.change_ring(Zmod(<span class="hljs-built_in">pow</span>(p,r)))<br>    P = Zp(p,<span class="hljs-built_in">max</span>(<span class="hljs-number">30</span>, r))<br>    Fd = derivative(F)<br>    origin_roots = f.roots()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(origin_roots):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;f has no roots&quot;</span>)<br>    ans = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> origin_roots:<br>        x_k = ZZ(x[<span class="hljs-number">0</span>])<br>        flag = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,r):<br>            <span class="hljs-keyword">if</span> Fd(x_k) == P(<span class="hljs-number">0</span>):<br>                <span class="hljs-keyword">if</span> Zmod(<span class="hljs-built_in">pow</span>(p,r))(f(x_k)) == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                x_k = Zmod(<span class="hljs-built_in">pow</span>(p,r))(P(x_k)-P(F(x_k))/P(Fd(x_k)))<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:<br>            ans.update(&#123;x_k&#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(ans)<br></code></pre></td></tr></table></figure><p>发布在了pypi上，包名是sageball，以后有空继续加东西 :)</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install sageball<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">sage: <span class="hljs-keyword">from</span> sageball <span class="hljs-keyword">import</span> *<br>sage: <span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>sage: p = getPrime(<span class="hljs-number">256</span>)<br>sage: R.&lt;y&gt; = PolynomialRing(Zmod(p**<span class="hljs-number">20</span>))<br>sage: f = y^<span class="hljs-number">3</span> + <span class="hljs-number">88</span>*y^<span class="hljs-number">2</span> - <span class="hljs-number">99999</span><br>sage: f.change_ring(Zmod(p)).roots()<br>[(<span class="hljs-number">69308405488968049481748767212436730722801895792767406183685348133444233479868</span>,<br>  <span class="hljs-number">1</span>)]<br>sage: hensel_solve(f, p, <span class="hljs-number">20</span>)<br>[<span class="hljs-number">37703239737291277027365421519817323510865478112086210957276760542087052163016132599406943585036792976177249575532822533382718659736377573208253677268888201655419242055704276470729367796428426925172977074351292389204307294573364430803709392333960546348414634462190043821875241702966811101872263679102636643307528125089896228460596363355183960529903004848582857601840357174398281039729957164593085194467208379329098387709805523851043891922678228619680505251195773703511681160617319758877015996276560753899603002631615128325997643360635074115199442764683911096103905062585582942055722166181353528675325076096297244626026449521382868966037541063655163348755341756755617940070562452441891408449830499203414189319262630366583841725437180190345364849360870085927141091486810600074199897251843646588089235927963654342587841938352499246682037892369415183228114192308636949277636053376129783325911050681522271118165681832491205844031365819303630911196836805570188269207857049649045106759562098511078380779871363209078702905615571385458121535111843353457641165749407944240106157067093368333261474712361323801567878571827355353862484780988204946203231824057103525010377318719780405547502696530468817018627278660067985068655748252348692956763839842442577386154738340668457963492309894080502092443676751298594398480522893553162155245967675698842596912463075386927752665256904505233043287372778132982200372598578779053114623191692012462398153277118305607887829172213095033538161975762360571566038379832338161703977843510412337910651837461493861836641371994</span>]<br>sage: f(<span class="hljs-number">3770323973729127702736542151981732351086547811208621095727676054208705216301613259940694358503679297617724957553</span><br>....: <span class="hljs-number">282253338271865973637757320825367726888820165541924205570427647072936779642842692517297707435129238920430729457336</span><br>....: <span class="hljs-number">443080370939233396054634841463446219004382187524170296681110187226367910263664330752812508989622846059636335518396</span><br>....: 052990300484858285760184035717439828103972995716459308519446720837932909838770980552385104389192267822861968050525<br>....: <span class="hljs-number">119577370351168116061731975887701599627656075389960300263161512832599764336063507411519944276468391109610390506258</span><br>....: <span class="hljs-number">558294205572216618135352867532507609629724462602644952138286896603754106365516334875534175675561794007056245244189</span><br>....: <span class="hljs-number">140844983049920341418931926263036658384172543718019034536484936087008592714109148681060007419989725184364658808923</span><br>....: <span class="hljs-number">592796365434258784193835249924668203789236941518322811419230863694927763605337612978332591105068152227111816568183</span><br>....: <span class="hljs-number">249120584403136581930363091119683680557018826920785704964904510675956209851107838077987136320907870290561557138545</span><br>....: <span class="hljs-number">812153511184335345764116574940794424010615706709336833326147471236132380156787857182735535386248478098820494620323</span><br>....: <span class="hljs-number">182405710352501037731871978040554750269653046881701862727866006798506865574825234869295676383984244257738615473834</span><br>....: 066845796349230989408050209244367675129859439848052289355316215524596767569884259691246307538692775266525690450523<br>....: <span class="hljs-number">304328737277813298220037259857877905311462319169201246239815327711830560788782917221309503353816197576236057156603</span><br>....: <span class="hljs-number">8379832338161703977843510412337910651837461493861836641371994</span>)<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sagemath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客配置</title>
    <link href="/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>使用github + Hexo, 主题Fluid</p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>安装hexo: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i hexo-cli -g<br></code></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br>npm install<br></code></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件：_config.yml</p><p>配置部署到github page</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">https://github.com/pikaball/pikaball.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>新建post：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &quot;Title&quot;<br></code></pre></td></tr></table></figure><p>编辑source&#x2F;_posts目录下的markdown文件，默认生成Front-matter</p><blockquote><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章的永久链接，永久链接应该以 &#x2F; 或 .html 结尾</td><td>null</td></tr><tr><td>excerpt</td><td>纯文本的页面摘要。</td><td></td></tr><tr><td>disableNunjucks</td><td>启用时禁用 Nunjucks 标签 {{ }}&#x2F;{% %} 和 标签插件 的渲染功能</td><td>false</td></tr><tr><td>lang</td><td>设置语言以覆盖自动检测</td><td>继承自 _config.yml</td></tr></tbody></table><h2 id="生成、部署"><a href="#生成、部署" class="headerlink" title="生成、部署"></a>生成、部署</h2><p>markdown源文件渲染为静态html:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>部署到服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>部署到本地端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><h1 id="Theme-Fluid"><a href="#Theme-Fluid" class="headerlink" title="Theme: Fluid"></a>Theme: Fluid</h1><p><a href="https://hexo.fluid-dev.com/docs/guide/">Fluid文档</a></p><p>从<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Release</a>下载，解压到themes目录下，命名为fluid，在Hexo的<code>_config.yml</code>中指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span> <br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h2 id="封面-首部图片"><a href="#封面-首部图片" class="headerlink" title="封面&amp;首部图片"></a>封面&amp;首部图片</h2><p><strong>front-matter:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span><br></code></pre></td></tr></table></figure><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">excerpt:</span> <br></code></pre></td></tr></table></figure><h2 id="启用MathJAX"><a href="#启用MathJAX" class="headerlink" title="启用MathJAX"></a>启用MathJAX</h2><p>themes&#x2F;fluid&#x2F;_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
