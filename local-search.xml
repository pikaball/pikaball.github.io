<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[syzkaller源码阅读] 0. Run &amp; Read doc</title>
    <link href="/2025/04/04/syzkaller%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-0-Run-Read-doc/"/>
    <url>/2025/04/04/syzkaller%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-0-Run-Read-doc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>出于毕设和研究生阶段的工作需要，我不得不尽早做完syzkaller的审计工作。为了方便复盘和分享，干脆边审边写blog了，挖个大坑。</p></blockquote><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p><a href="https://github.com/google/syzkaller">syzkaller</a>是目前最流行的内核模糊测试框架，要fuzz内核的话基本上没有别的更好的选择。</p><blockquote><p>注：整个审计工作将保持在这个commit上进行：<code>c799dfdd5648677612604d10e2c13075eda21582</code> </p></blockquote><p>如果你此前没有审计过go项目，也不是很懂fuzz，那么应该先对着readme给项目跑起来，再去读一遍文档，理解开发者的设计意图，做完了这些事情，才可以有底气去开始我们的审计。</p><p>运行第一个kernel fuzz实例并不困难，照着readme一步一步来就好了，大概的步骤是编译syzkaller -&gt; 编译内核 -&gt; 创建用户空间镜像 -&gt; syzkaller config -&gt; Run syz-manager, 主要参阅<code>docs/setup.md</code>, <code>docs/usage.md</code></p><p>你可以从syzkaller的在线实例上获取现成的kernel config: <a href="https://syzkaller.appspot.com/upstream">syzbot</a></p><p>这是一个syzkaller config示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux/amd64&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;http&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.0.0.0:56741&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;workdir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/v6.11&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;kernel_obj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/linux&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/v6.11/bullseye.img&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;syzkaller&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/syzkaller&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sshkey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/v6.11/bullseye.id_rsa&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;procs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">12</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qemu&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;vm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;cpu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;mem&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8192</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;kernel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/pikaball/work/fuzz/linux/arch/x86/boot/bzImage&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>syz-manager</code>跑起来之后，访问你在配置文件中指定的webui地址，应该可以看到如下仪表盘：</p><p><img src="/../img/syzkaller/0/dashboard.png" alt="syz-manager dashboard"></p><p>多运行一段时间，确认vm没有爆出一些一看就不对的错误。</p><ul><li><strong>lost connection</strong>: ssh 出问题了，建议在syzkaller启动前用你获得的内核镜像和用户空间镜像手动起一个qemu，看看能不能走ssh连进去</li><li><strong>no output from test machine</strong>: 多半是内核编译得不对，请确保采用了版本完全匹配的<code>.config</code></li></ul><p>总之，fuzz顺利启动了，接下来我们去从头到尾看一遍文档。</p><h1 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h1><p>syzkaller根目录的readme给了一些指引：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [<span class="hljs-string">How to install syzkaller</span>](<span class="hljs-link">docs/setup.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to use syzkaller</span>](<span class="hljs-link">docs/usage.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How syzkaller works</span>](<span class="hljs-link">docs/internals.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to install syzbot</span>](<span class="hljs-link">docs/setup_syzbot.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to contribute to syzkaller</span>](<span class="hljs-link">docs/contributing.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">How to report Linux kernel bugs</span>](<span class="hljs-link">docs/linux/reporting_kernel_bugs.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Tech talks and articles</span>](<span class="hljs-link">docs/talks.md</span>)<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Research work based on syzkaller</span>](<span class="hljs-link">docs/research.md</span>)<br></code></pre></td></tr></table></figure><p>另外，docs目录下有一些子目录，对应不同os，看<code>linux</code>目录下的文件即可。</p><p>我们暂时只关心“Linux的fuzz工作是如何运作的”，别的都可以先不看。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><code>docs/internals.md</code>介绍了syzkaller的运行结构.</p><p><code>docs/linux/internals.md</code> -&gt; [<code>docs/linux/external_fuzzing_network.md</code> , <code>docs/linux/external_fuzzing_usb.md</code>] 介绍了linux下的特殊工作结构，即关于如何fuzz network模块和USB模块，这部分将在后文提及，暂时跳过。</p><p>syzkaller的结构如下图所示。</p><p><img src="/../img/syzkaller/0/process_structure.png" alt="syzkaller process structure"></p><p>syzkaller的主要组件是<code>syz-manager</code>和<code>syz-executor</code>, 前者在host上运行，控制整个fuzz工作，后者在vm上运行，负责在vm中执行程序并向manager发送反馈信息（报错，覆盖率等）。</p><p>在启动一个vm时，<code>syz-manager</code>通过ssh发送静态编译的executor并运行，之后，manager和executor将通过rpc协议进行通信。</p><p>syzkaller对vm的每一个输入都是由一串系统调用构成的程序，即syscall序列。</p><p>为什么是syscall序列？我们fuzz的对象是内核，目标是由用户态输入引发内核异常，而用户态和内核态的主要交互方式就是系统调用，至于其他交互方式，比如硬件上的插拔，这也可以使用自定义的syscall模拟，我们将在network和usb的部分看到这样的伪syscall。</p><p>syz-manager运行时会维护workdir，workdir中包含崩溃用例（crashes）和语料库（corpus），可以做这样一个简单描述：如果一个fuzz输入（syscall序列）运行时产生了任何告警或错误，那么就将其算作crash；如果一个fuzz输入产生了新的覆盖，那么就将其加入语料库。语料库的作用就是提供fuzz变异的种子，即在一个“有趣的用例”的基础上进一步测试。</p><h2 id="syzlang"><a href="#syzlang" class="headerlink" title="syzlang"></a>syzlang</h2><p>我们已经知道syzkaller在做的事是不断生成syscall序列发到虚拟机里执行，那么这些序列是如何被构造的呢？</p><p>syzkaller使用syscall description language(简称syzlang) 来描述系统调用的参数约束，以下是文档中给出的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd<br>read(fd fd, buf buffer[out], count len[buf])<br>close(fd fd)<br>open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>这个示例本身是过于简单的，可以在<code>sys/$os</code>下看到syzkaller预置的syzlang，比如在<code>sys/linux/dev_fb.txt</code>中，可以看到这样的规约：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">openat<span class="hljs-variable">$fb0</span>(fd const<span class="hljs-selector-attr">[AT_FDCWD]</span>, file ptr<span class="hljs-selector-attr">[in, string[<span class="hljs-string">&quot;/dev/fb0&quot;</span>]</span>], flags flags<span class="hljs-selector-attr">[open_flags]</span>, mode const<span class="hljs-selector-attr">[0]</span>) fd_fb<br>openat<span class="hljs-variable">$fb1</span>(fd const<span class="hljs-selector-attr">[AT_FDCWD]</span>, file ptr<span class="hljs-selector-attr">[in, string[<span class="hljs-string">&quot;/dev/fb1&quot;</span>]</span>], flags flags<span class="hljs-selector-attr">[open_flags]</span>, mode const<span class="hljs-selector-attr">[0]</span>) fd_fb<br><br>write<span class="hljs-variable">$fb</span>(fd fd_fb, data ptr<span class="hljs-selector-attr">[in, array[int8]</span>], len bytesize<span class="hljs-selector-attr">[data]</span>)<br>read<span class="hljs-variable">$fb</span>(fd fd_fb, data ptr<span class="hljs-selector-attr">[out, array[int8]</span>], len bytesize<span class="hljs-selector-attr">[data]</span>)<br>mmap<span class="hljs-variable">$fb</span>(addr vma, len len<span class="hljs-selector-attr">[addr]</span>, prot flags<span class="hljs-selector-attr">[mmap_prot]</span>, flags flags<span class="hljs-selector-attr">[mmap_flags]</span>, fd fd_fb, off intptr<span class="hljs-selector-attr">[0:0x100000, 0x1000]</span>)<br></code></pre></td></tr></table></figure><p>注意到系统调用名后有<code>$</code>符号，这是表示使用不同参数约束的syscall，例如上面的两个openat。（syzlang的详细语法描述可以参见<code>docs/syscall_descriptions_syntax.md</code>）</p><p>这样做的好处显而易见，因为有些syscall的处理逻辑非常多，在不同功能&#x2F;模块下需要不同的参数约束，典型的例子是ioctl，其行为完全取决于传入的cmd参数以及绑定的设备文件，我们在kernel中可以看到ioctl的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(ioctl, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg)<br>&#123;<br>CLASS(fd, f)(fd);<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (fd_empty(f))<br><span class="hljs-keyword">return</span> -EBADF;<br><br>error = security_file_ioctl(fd_file(f), cmd, arg);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br>error = do_vfs_ioctl(fd_file(f), fd, cmd, arg);<br><span class="hljs-keyword">if</span> (error == -ENOIOCTLCMD)<br>error = vfs_ioctl(fd_file(f), cmd, arg);<br><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们按照这个定义在syslang中直接这样写而不添加其变种：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ioctl(fd <span class="hljs-built_in">int32</span>, cmd <span class="hljs-built_in">int32</span>, arg <span class="hljs-built_in">int64</span>)<br></code></pre></td></tr></table></figure><p>……那就完蛋了，fuzz跑到猴年马月都出不了成果。举个例子，usb bus上的控制消息传递，需要一个指向usb设备的fd，特定的cmd值，并且把arg构造成指向一个urb的指针才可以进到相关逻辑。</p><p>而在syzlang中把这样的syscall拆分成带有更具体语义的变种，fuzz时就可以产生更多有效的输入和变异，提高fuzz效率。</p><p>syzkaller中内置的规约基本是完善的，虽然针对大量协议可以进一步做细化，但这个话题不在本系列文章的讨论范围，我们直接拿着用就好了。</p><h2 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a>coverage</h2><p>在fuzz linux内核时，syzkaller依靠KCOV机制来完成覆盖率信息收集，覆盖率信息将会在更新语料库时起到参考作用。</p><p>启用选项<code>CONFIG_KCOV=y</code>，内核编译时会进行基本块插桩，当代码运行到这些位置就会进行kcov相关调用，返回程序运行时命中的地址，进而实现覆盖率记录。</p><p>在得到kcov信息后，syzkaller使用binutils将地址转换为源代码位置，<code>docs/linux/coverage.md</code>解释了这一步具体的操作流，此处略过。</p><p>在web dashboard上可以直观地查看kernel每一个源码文件的coverage(<code>/cover</code>)。</p><p><img src="/../img/syzkaller/0/coverage.png" alt="coverage"></p><h2 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h2><p>所有fuzz工具的目标都是产生crash，至于如何从crash到exploit，这不在fuzz的讨论范围内。</p><p>引用一下<a href="https://www.ruanx.net/afl-source-1/">机器猫先生的博客</a>：</p><blockquote><p>归根结底，一个漏洞到底有没有价值，需要很多外部知识——例如，假如某个输入能让程序额外运行一秒钟，这对于 nginx 来说是巨大问题；但对于 checkpng 之类的小程序，便是无关紧要的。一个缓冲区 over-read 漏洞，对于 openssl 是致命的，但对于 gimp 这类程序而言，只是多了个让程序崩溃的 bug，大家并不特别关心其安全方面的危险。由于一个漏洞的价值难以衡量，笔者决定不钻研这个问题，仍以 crash 数量为衡量 fuzzer 好坏的第一标准。</p></blockquote><h3 id="report"><a href="#report" class="headerlink" title="report"></a>report</h3><p>syzkaller在发现crash后将其保存至workdir。</p><p><img src="/../img/syzkaller/0/crash-log.png" alt="crash info"></p><p>其中，<code>description</code>作为crash的名称，<code>logN</code>是syzkaller执行该用例时的日志以及vm中的输出信息，<code>machineInfoN</code>是执行该用例的vm配置信息，<code>reportN</code>则是在前两者基础上经过处理的crash报告。</p><h3 id="reproduce"><a href="#reproduce" class="headerlink" title="reproduce"></a>reproduce</h3><p>fuzz过程中会分出一部分虚拟机用于crash的复现（reproduce）。复现的意义在于，将原始触发crash的syscall序列尽可能简化，并验证该crash是否稳定可重复。</p><p>syzkaller提供了两个复现器，<code>C reproducer</code>和<code>Syz reproducer</code>，优先使用后者。</p><p>fuzz运行一段时间后，dashboard上就可以看到crash的信息了：</p><p><img src="/../img/syzkaller/0/crash.png" alt="crash"></p><p><code>has repro</code>表示使用<code>Syz reproducer</code>复现成功，提供一个syscall序列：</p><p><img src="/../img/syzkaller/0/syz-repro.png" alt="Syz repro"></p><p><code>has C repro</code>则对应<code>C reproducer</code>，提供一个C编写的程序。</p><p><img src="/../img/syzkaller/0/c-repro.png" alt="C repro"></p><p>此外，还可以使用syzkaller提供的工具进行手动reproduce并执行复现程序，参考<code>docs/reproducing_crashes.md</code></p><h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><p>syzkaller提供了很多实用小工具，都在<code>/tools</code>目录下。</p><p><code>syz-cover</code>可以使用kcov信息（从web dashboard的<code>/rawcover</code>获取）生成可视化的coverage报告，<code>syz-benchcmp</code>可以接收两个覆盖率记录生成对比图，<code>syz-db</code>可以添加&#x2F;移除corpus.db中的语料，其他的在这里就不一一列举了，可以自行探索。</p><h1 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h1><p>本文梳理了syzkaller的启动流程和文档信息，大致描述了syzkaller的运行结构，从文档初窥syzkaller的系统性设计思路。下一篇将正式开始源码审计，分析syzkaller的架构逻辑和策略实现。</p>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>code review</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php容器远程调试指北</title>
    <link href="/2024/08/07/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/"/>
    <url>/2024/08/07/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h1><p>本机windows，服务器Ubuntu，服务器上跑一个php docker容器，本机使用IDE PhpStorm，需要服务器可以通过ip访问到本机。</p><p>本文以一个thinkphp应用为例，本机和服务器上各有一份代码。</p><p>容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 8000:8000 -p 9003:9003 -v .:/think php:8 /bin/bash<br></code></pre></td></tr></table></figure><p>8000是web端口，9003是调试端口</p><h1 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h1><h2 id="容器内安装Xdebug"><a href="#容器内安装Xdebug" class="headerlink" title="容器内安装Xdebug"></a>容器内安装Xdebug</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pecl install xdebug<br>docker-php-ext-enable xdebug<br></code></pre></td></tr></table></figure><p>xdebug安装成功时会回显xdebug.so的路径，待会要写到配置文件里。</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/xdebug-install.png"></p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install -y vim<br>vim /usr/local/etc/php/conf.d/xdebug.ini<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">zend_extension</span>=/usr/local/lib/php/extensions/<span class="hljs-literal">no</span>-debug-non-zts-<span class="hljs-number">20230831</span>/xdebug.so<br><span class="hljs-attr">xdebug.idekey</span>=PHPSTORM<br><span class="hljs-comment">; 进行调试所需要携带的IDEKEY</span><br><span class="hljs-attr">xdebug.discover_client_host</span> = <span class="hljs-literal">Off</span><br><span class="hljs-attr">xdebug.client_host</span>=<span class="hljs-string">&quot;x.x.x.x&quot;</span><br><span class="hljs-comment">; 这里是物理机，即IDE所在机器的ip</span><br><span class="hljs-attr">xdebug.mode</span>=profile,trace,debug<br><span class="hljs-attr">xdebug.start_with_request</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">xdebug.client_port</span> = <span class="hljs-number">9003</span><br><span class="hljs-attr">xdebug.remote_handler</span> = dbgp<br><span class="hljs-attr">xdebug.log</span> = /tmp/xdebug.log<br><span class="hljs-attr">xdebug.remote_enable</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">xdebug.remote_port</span> = <span class="hljs-number">9003</span><br></code></pre></td></tr></table></figure><h2 id="IDE配置"><a href="#IDE配置" class="headerlink" title="IDE配置"></a>IDE配置</h2><p><code>Settings -&gt; PHP</code>，首先为你的IDE添加一个可用的php解释器，我这里直接用了服务器上的，版本没有严格要求，差不太多就行</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/interpreter.png"></p><p>然后添加一个服务器，端口是web的端口，添加文件路径映射</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/serverconfi.png"></p><p><code>PHP -&gt; 调试</code>，确认一下调试端口是否正确</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/port.png"></p><p><code>PHP -&gt; 调试 -&gt; DBGp代理</code>，填一下IDEKEY和服务器的ip-port，与调试端口一致</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/DBGp_proxy.png"></p><p>最后添加一个PHP远程调试配置，服务器选择之前在设置里添加过的，然后填写IDEKEY</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/debug_config.png"></p><h1 id="开始debug"><a href="#开始debug" class="headerlink" title="开始debug"></a>开始debug</h1><p>IDE里下个断点，用刚才的配置开始调试</p><p><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/breakpoint.png"></p><p>到web根目录把服务跑起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">php think run<br></code></pre></td></tr></table></figure><p>浏览器发一个能使代码运行到断点处的请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/Lilac/de?data=aaaa<br></code></pre></td></tr></table></figure><p>就能看到断下来了：<br><img src="/../img/php%E5%AE%B9%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97/debug.png"></p><h1 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h1><p>遇到过一些很抽象的问题……总之如果断不下来，可以尝试如下思路：</p><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p>IDE重新开启调试，以及重启web服务，两边都试试，并且可能受到重启的次序的影响</p><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>请求里加个get参数：<code>XDEBUG_SESSION_START=PHPSTORM</code></p><p>P.S. 搜索到的文章都写到了这一点，但事实上似乎没加也能断。</p><p>如果确定是这个问题，那么你可以安装一个叫Xdebug Helper的浏览器插件，它可以帮你自动化完成这个操作，不需要每次手动加。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hensel&#39;s Lifting Method</title>
    <link href="/2024/03/22/Hensel-s-Lifting-Method/"/>
    <url>/2024/03/22/Hensel-s-Lifting-Method/</url>
    
    <content type="html"><![CDATA[<p>近日尝试用sagemath自带的roots()求解$f(x) \equiv 0 \pmod{p^a}$，发现速度极慢。了解到Hensel’s Lemma可以解决这个问题，但我在sagemath的申必文档中并未搜索到该方法的直接实现。故自己写了一个。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><a href="https://en.wikipedia.org/wiki/Hensel's_lemma">Hensel’s lemma</a></p><p>Hensel’s Lemma 用于将 $f(x) \equiv 0 \pmod {p}$ 的解提升至$Zmod(p^a)$. (p为素数)</p><br><p>下面的算法称之为 <strong>Hensel’s lifting method</strong> :</p><p>首先，已知$x \equiv r_{k-1}$ 为 $f(x) \equiv 0 \pmod {p^{k-1}}$ 的解。</p><p>接下来将数域由$GF(p^{k-1})$提升至$GF(p^k)$，记 $r_k$ 为 $f(x) \equiv 0 \pmod {p^{k}}$ 的解</p><ul><li>若 $f’(r_{k-1}) \not\equiv 0$, 则有唯一的$t$使得 $f(r_{k-1} + tp^{k-1}) \equiv 0 \pmod{p^k}$ 成立，此时$r_k &#x3D; r_{k-1} - \displaystyle\frac{f(r_{k-1})}{f’(r_{k-1})}$</li><li>若 $f’(r_{k-1}) \equiv 0$, 且 $f(r_{k-1}) \equiv 0$，则t为任意整数，$r_k &#x3D; r_{k-1}$</li><li>若 $f’(r_{k-1}) \equiv 0$, 且 $f(r_{k-1}) \not\equiv 0$，则没有满足条件的整数t，无法利用$r_{k-1}$求解</li></ul><p>以上步骤循环，可以将$f(x) \equiv 0$ 在 $GF(p^a)$上的求解规约到 $GF(p)$</p><br><p>注意到$\displaystyle\frac{f(r_{k-1})}{f’(r_{k-1})}$未必能直接产生整数，将计算放到p-adic ring上更方便。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hensel_solve</span>(<span class="hljs-params">f, p, r</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Solves polynomial roots in the ring Zmod(p**r) using Hensel&#x27;s lifting method.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Parameters:</span><br><span class="hljs-string">    f (polynomial): The polynomial equation.</span><br><span class="hljs-string">    p (int): A prime number.</span><br><span class="hljs-string">    r (int): The exponent.</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Raises:</span><br><span class="hljs-string">    ValueError: If p is not a prime number or if f has no roots.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_prime(p):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;p must be a prime&quot;</span>)<br>    f = f.change_ring(Zp(p))<br>    F = f.change_ring(Zmod(<span class="hljs-built_in">pow</span>(p,r)))<br>    P = Zp(p,<span class="hljs-built_in">max</span>(<span class="hljs-number">30</span>, r))<br>    Fd = derivative(F)<br>    origin_roots = f.roots()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(origin_roots):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;f has no roots&quot;</span>)<br>    ans = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> origin_roots:<br>        x_k = ZZ(x[<span class="hljs-number">0</span>])<br>        flag = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,r):<br>            <span class="hljs-keyword">if</span> Fd(x_k) == P(<span class="hljs-number">0</span>):<br>                <span class="hljs-keyword">if</span> Zmod(<span class="hljs-built_in">pow</span>(p,r))(f(x_k)) == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                x_k = Zmod(<span class="hljs-built_in">pow</span>(p,r))(P(x_k)-P(F(x_k))/P(Fd(x_k)))<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:<br>            ans.update(&#123;x_k&#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(ans)<br></code></pre></td></tr></table></figure><p>发布在了pypi上，包名是sageball，以后有空继续加东西 :)</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install sageball<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">sage: <span class="hljs-keyword">from</span> sageball <span class="hljs-keyword">import</span> *<br>sage: <span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>sage: p = getPrime(<span class="hljs-number">256</span>)<br>sage: R.&lt;y&gt; = PolynomialRing(Zmod(p**<span class="hljs-number">20</span>))<br>sage: f = y^<span class="hljs-number">3</span> + <span class="hljs-number">88</span>*y^<span class="hljs-number">2</span> - <span class="hljs-number">99999</span><br>sage: f.change_ring(Zmod(p)).roots()<br>[(<span class="hljs-number">69308405488968049481748767212436730722801895792767406183685348133444233479868</span>,<br>  <span class="hljs-number">1</span>)]<br>sage: hensel_solve(f, p, <span class="hljs-number">20</span>)<br>[<span class="hljs-number">37703239737291277027365421519817323510865478112086210957276760542087052163016132599406943585036792976177249575532822533382718659736377573208253677268888201655419242055704276470729367796428426925172977074351292389204307294573364430803709392333960546348414634462190043821875241702966811101872263679102636643307528125089896228460596363355183960529903004848582857601840357174398281039729957164593085194467208379329098387709805523851043891922678228619680505251195773703511681160617319758877015996276560753899603002631615128325997643360635074115199442764683911096103905062585582942055722166181353528675325076096297244626026449521382868966037541063655163348755341756755617940070562452441891408449830499203414189319262630366583841725437180190345364849360870085927141091486810600074199897251843646588089235927963654342587841938352499246682037892369415183228114192308636949277636053376129783325911050681522271118165681832491205844031365819303630911196836805570188269207857049649045106759562098511078380779871363209078702905615571385458121535111843353457641165749407944240106157067093368333261474712361323801567878571827355353862484780988204946203231824057103525010377318719780405547502696530468817018627278660067985068655748252348692956763839842442577386154738340668457963492309894080502092443676751298594398480522893553162155245967675698842596912463075386927752665256904505233043287372778132982200372598578779053114623191692012462398153277118305607887829172213095033538161975762360571566038379832338161703977843510412337910651837461493861836641371994</span>]<br>sage: f(<span class="hljs-number">3770323973729127702736542151981732351086547811208621095727676054208705216301613259940694358503679297617724957553</span><br>....: <span class="hljs-number">282253338271865973637757320825367726888820165541924205570427647072936779642842692517297707435129238920430729457336</span><br>....: <span class="hljs-number">443080370939233396054634841463446219004382187524170296681110187226367910263664330752812508989622846059636335518396</span><br>....: 052990300484858285760184035717439828103972995716459308519446720837932909838770980552385104389192267822861968050525<br>....: <span class="hljs-number">119577370351168116061731975887701599627656075389960300263161512832599764336063507411519944276468391109610390506258</span><br>....: <span class="hljs-number">558294205572216618135352867532507609629724462602644952138286896603754106365516334875534175675561794007056245244189</span><br>....: <span class="hljs-number">140844983049920341418931926263036658384172543718019034536484936087008592714109148681060007419989725184364658808923</span><br>....: <span class="hljs-number">592796365434258784193835249924668203789236941518322811419230863694927763605337612978332591105068152227111816568183</span><br>....: <span class="hljs-number">249120584403136581930363091119683680557018826920785704964904510675956209851107838077987136320907870290561557138545</span><br>....: <span class="hljs-number">812153511184335345764116574940794424010615706709336833326147471236132380156787857182735535386248478098820494620323</span><br>....: <span class="hljs-number">182405710352501037731871978040554750269653046881701862727866006798506865574825234869295676383984244257738615473834</span><br>....: 066845796349230989408050209244367675129859439848052289355316215524596767569884259691246307538692775266525690450523<br>....: <span class="hljs-number">304328737277813298220037259857877905311462319169201246239815327711830560788782917221309503353816197576236057156603</span><br>....: <span class="hljs-number">8379832338161703977843510412337910651837461493861836641371994</span>)<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sagemath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客配置</title>
    <link href="/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>使用github + Hexo, 主题Fluid</p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>安装hexo: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i hexo-cli -g<br></code></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br>npm install<br></code></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件：_config.yml</p><p>配置部署到github page</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">https://github.com/pikaball/pikaball.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>新建post：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &quot;Title&quot;<br></code></pre></td></tr></table></figure><p>编辑source&#x2F;_posts目录下的markdown文件，默认生成Front-matter</p><blockquote><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量</p></blockquote><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章的永久链接，永久链接应该以 &#x2F; 或 .html 结尾</td><td>null</td></tr><tr><td>excerpt</td><td>纯文本的页面摘要。</td><td></td></tr><tr><td>disableNunjucks</td><td>启用时禁用 Nunjucks 标签 {{ }}&#x2F;{% %} 和 标签插件 的渲染功能</td><td>false</td></tr><tr><td>lang</td><td>设置语言以覆盖自动检测</td><td>继承自 _config.yml</td></tr></tbody></table><h2 id="生成、部署"><a href="#生成、部署" class="headerlink" title="生成、部署"></a>生成、部署</h2><p>markdown源文件渲染为静态html:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>部署到服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>部署到本地端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><h1 id="Theme-Fluid"><a href="#Theme-Fluid" class="headerlink" title="Theme: Fluid"></a>Theme: Fluid</h1><p><a href="https://hexo.fluid-dev.com/docs/guide/">Fluid文档</a></p><p>从<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Release</a>下载，解压到themes目录下，命名为fluid，在Hexo的<code>_config.yml</code>中指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span> <br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><h2 id="封面-首部图片"><a href="#封面-首部图片" class="headerlink" title="封面&amp;首部图片"></a>封面&amp;首部图片</h2><p><strong>front-matter:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span><br></code></pre></td></tr></table></figure><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">excerpt:</span> <br></code></pre></td></tr></table></figure><h2 id="启用MathJAX"><a href="#启用MathJAX" class="headerlink" title="启用MathJAX"></a>启用MathJAX</h2><p>themes&#x2F;fluid&#x2F;_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
